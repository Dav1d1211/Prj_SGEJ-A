package application.dao;

import application.database.DatabaseConnection;
import application.model.Usuario;

import java.sql.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

/**
 * Data Access Object para la gestión de usuarios
 */
public class UsuarioDAO {

    /**
     * Agrega un nuevo usuario en la base de datos
     * @param usuario el usuario a insertar
     * @return true si se insertó correctamente, false en caso contrario
     */
    public boolean agregarUsuario(Usuario usuario) {
        String sql = """
            INSERT INTO usuarios (nombres, apellidos, identificacion, email,
                                  nombre_usuario, clave, tipo_usuario, estado_usuario,
                                  created_at, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """;

        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            pstmt.setString(1, usuario.getNombres());
            pstmt.setString(2, usuario.getApellidos());
            pstmt.setString(3, usuario.getIdentificacion());
            pstmt.setString(4, usuario.getEmail());
            pstmt.setString(5, usuario.getNombreUsuario());
            pstmt.setString(6, usuario.getClave());
            pstmt.setString(7, usuario.getTipoUsuario().name());
            pstmt.setString(8, usuario.getEstadoUsuario().name());
            pstmt.setString(9, LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
            pstmt.setString(10, LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));

            int affectedRows = pstmt.executeUpdate();
            
            if (affectedRows > 0) {
                try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        usuario.setId(generatedKeys.getInt(1));
                        return true;
                    }
                }
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Error al insertar usuario: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }
    
    /**
     * Actualiza un usuario existente en la base de datos
     * @param usuario el usuario a actualizar
     * @return true si se actualizó correctamente, false en caso contrario
     */
    public boolean actualizarUsuario(Usuario usuario) {
        String sql = """
            UPDATE usuarios SET 
                nombres = ?, 
                apellidos = ?, 
                identificacion = ?, 
                email = ?,
                nombre_usuario = ?, 
                clave = ?, 
                tipo_usuario = ?, 
                estado_usuario = ?, 
                updated_at = ?
            WHERE id = ?
            """;

        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setString(1, usuario.getNombres());
            pstmt.setString(2, usuario.getApellidos());
            pstmt.setString(3, usuario.getIdentificacion());
            pstmt.setString(4, usuario.getEmail());
            pstmt.setString(5, usuario.getNombreUsuario());
            pstmt.setString(6, usuario.getClave());
            pstmt.setString(7, usuario.getTipoUsuario().name());
            pstmt.setString(8, usuario.getEstadoUsuario().name());
            pstmt.setString(9, LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
            pstmt.setInt(10, usuario.getId());

            int affectedRows = pstmt.executeUpdate();
            return affectedRows > 0;
        } catch (SQLException e) {
            System.err.println("Error al actualizar usuario: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }
    
    /**
     * Elimina un usuario por su ID
     * @param id ID del usuario a eliminar
     * @return true si se eliminó correctamente, false en caso contrario
     */
    public boolean eliminarUsuario(Integer id) {
        String sql = "DELETE FROM usuarios WHERE id = ?";

        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setInt(1, id);
            int affectedRows = pstmt.executeUpdate();
            return affectedRows > 0;
        } catch (SQLException e) {
            System.err.println("Error al eliminar usuario: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }
    
    /**
     * Obtiene todos los usuarios de la base de datos
     * @return lista de usuarios
     */
    public List<Usuario> obtenerTodosLosUsuarios() throws SQLException {
        List<Usuario> usuarios = new ArrayList<>();
        String sql = "SELECT * FROM usuarios";

        try (Connection conn = DatabaseConnection.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {

            while (rs.next()) {
                Usuario usuario = mapResultSetToUsuario(rs);
                usuarios.add(usuario);
            }
        }
        return usuarios;
    }
    
    /**
     * Busca usuarios por nombre, nombre de usuario o identificación
     * @param termino término de búsqueda
     * @return lista de usuarios que coinciden con el término
     */
    public List<Usuario> buscarUsuarios(String termino) throws SQLException {
        List<Usuario> usuarios = new ArrayList<>();
        String sql = """
            SELECT * FROM usuarios 
            WHERE nombres LIKE ? 
               OR apellidos LIKE ? 
               OR identificacion LIKE ?
               OR nombre_usuario LIKE ?
            """;

        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            String searchTerm = "%" + termino + "%";
            pstmt.setString(1, searchTerm);
            pstmt.setString(2, searchTerm);
            pstmt.setString(3, searchTerm);
            pstmt.setString(4, searchTerm);

            try (ResultSet rs = pstmt.executeQuery()) {
                while (rs.next()) {
                    Usuario usuario = mapResultSetToUsuario(rs);
                    usuarios.add(usuario);
                }
            }
        }
        return usuarios;
    }
    
    /**
     * Obtiene un usuario por su nombre de usuario
     * @param nombreUsuario nombre de usuario
     * @return usuario encontrado o null si no existe
     */
    public Usuario obtenerUsuarioPorNombreUsuario(String nombreUsuario) throws SQLException {
        String sql = "SELECT * FROM usuarios WHERE nombre_usuario = ?";

        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setString(1, nombreUsuario);
            
            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    return mapResultSetToUsuario(rs);
                }
            }
        }
        return null;
    }
    
    /**
     * Obtiene un usuario por su nombre (método equivalente para compatibilidad)
     */
    public Usuario obtenerUsuarioPorNombre(String nombreUsuario) throws SQLException {
        return obtenerUsuarioPorNombreUsuario(nombreUsuario);
    }
    
    /**
     * Verifica si la clave de un usuario es correcta
     * @param nombreUsuario nombre de usuario
     * @param clave clave a verificar
     * @return true si la clave es correcta, false en caso contrario
     */
    public boolean verificarClave(String nombreUsuario, String clave) throws SQLException {
        String sql = "SELECT clave FROM usuarios WHERE nombre_usuario = ?";

        try (Connection conn = DatabaseConnection.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setString(1, nombreUsuario);
            
            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    String claveAlmacenada = rs.getString("clave");
                    return claveAlmacenada != null && claveAlmacenada.equals(clave);
                }
            }
        }
        return false;
    }
    
    /**
     * Mapea un ResultSet a un objeto Usuario
     * @param rs ResultSet
     * @return objeto Usuario
     */
    private Usuario mapResultSetToUsuario(ResultSet rs) throws SQLException {
        Usuario usuario = new Usuario();
        
        usuario.setId(rs.getInt("id"));
        usuario.setNombres(rs.getString("nombres"));
        usuario.setApellidos(rs.getString("apellidos"));
        usuario.setIdentificacion(rs.getString("identificacion"));
        usuario.setEmail(rs.getString("email"));
        usuario.setNombreUsuario(rs.getString("nombre_usuario"));
        usuario.setClave(rs.getString("clave"));
        
        // Manejar enums
        try {
            usuario.setTipoUsuario(Usuario.TipoUsuario.valueOf(rs.getString("tipo_usuario")));
        } catch (Exception e) {
            usuario.setTipoUsuario(Usuario.TipoUsuario.INTERNO);
        }
        
        try {
            usuario.setEstadoUsuario(Usuario.EstadoUsuario.valueOf(rs.getString("estado_usuario")));
        } catch (Exception e) {
            usuario.setEstadoUsuario(Usuario.EstadoUsuario.ACTIVO);
        }
        
        // Fechas
        String createdAt = rs.getString("created_at");
        if (createdAt != null) {
            try {
                usuario.setCreatedAt(LocalDateTime.parse(createdAt, 
                    DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
            } catch (Exception e) {
                usuario.setCreatedAt(LocalDateTime.now());
            }
        }
        
        String updatedAt = rs.getString("updated_at");
        if (updatedAt != null) {
            try {
                usuario.setUpdatedAt(LocalDateTime.parse(updatedAt, 
                    DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
            } catch (Exception e) {
                usuario.setUpdatedAt(LocalDateTime.now());
            }
        }
        
        return usuario;
    }
}
